use std::sync::Arc;
use anyhow::Result;
use chrono::{DateTime, Utc};
use dashmap::DashMap;
use serde::{Deserialize, Serialize};
use tokio::sync::{mpsc, RwLock};
use tracing::{debug, error, info, warn};

use crate::config::Config;
use crate::kepler_client::{KeplerClient, CVE};
use crate::process_monitor::{ProcessEvent, ProcessInfo};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityDetection {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub process: ProcessInfo,
    pub vulnerabilities: Vec<CVE>,
    pub severity: SeverityLevel,
    pub alert_level: AlertLevel,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SeverityLevel {
    Critical,
    High,
    Medium,
    Low,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum AlertLevel {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum VulnerabilityEvent {
    VulnerabilityDetected {
        detection: VulnerabilityDetection,
    },
    ProcessScanned {
        timestamp: DateTime<Utc>,
        process: ProcessInfo,
        vulnerability_count: usize,
    },
    ScanComplete {
        timestamp: DateTime<Utc>,
        total_processes: usize,
        vulnerable_processes: usize,
        total_vulnerabilities: usize,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EngineStats {
    pub events_processed: u64,
    pub processes_scanned: u64,
    pub vulnerabilities_found: u64,
    pub high_severity_alerts: u64,
    pub unique_vulnerable_processes: u64,
    pub cache_hits: u64,
    pub cache_misses: u64,
}

pub struct VulnerabilityEngine {
    config: Config,
    kepler_client: Arc<KeplerClient>,
    event_sender: mpsc::UnboundedSender<VulnerabilityEvent>,
    detections: Arc<DashMap<String, VulnerabilityDetection>>,
    stats: Arc<RwLock<EngineStats>>,
}

impl VulnerabilityEngine {
    pub fn new(
        config: Config,
        kepler_client: Arc<KeplerClient>,
    ) -> (Self, mpsc::UnboundedReceiver<VulnerabilityEvent>) {
        let (tx, rx) = mpsc::unbounded_channel();
        
        let engine = Self {
            config,
            kepler_client,
            event_sender: tx,
            detections: Arc::new(DashMap::new()),
            stats: Arc::new(RwLock::new(EngineStats::default())),
        };
        
        (engine, rx)
    }

    pub async fn start(&self, mut process_events: mpsc::UnboundedReceiver<ProcessEvent>) -> Result<()> {
        info!("ðŸ§  Starting vulnerability detection engine...");
        
        while let Some(event) = process_events.recv().await {
            if let Err(e) = self.process_event(event).await {
                error!("Error processing event: {}", e);
            }
        }
        
        Ok(())
    }

    async fn process_event(&self, event: ProcessEvent) -> Result<()> {
        self.increment_stat("events_processed").await;
        
        match event {
            ProcessEvent::ProcessStart { process, .. } |
            ProcessEvent::ProcessScan { process, .. } => {
                self.handle_process_event(process).await?;
            }
            ProcessEvent::ProcessExit { pid, name, .. } => {
                self.handle_process_exit(pid, &name).await;
            }
        }
        
        Ok(())
    }

    async fn handle_process_event(&self, process: ProcessInfo) -> Result<()> {
        debug!("Processing process event for {} (PID: {})", process.name, process.pid);
        self.increment_stat("processes_scanned").await;

        if process.version == "unknown" {
            debug!("Skipping vulnerability check for {} (version unknown)", process.name);
            return Ok(());
        }

        info!("ðŸ” Checking vulnerabilities for {} v{}...", process.name, process.version);

        // Query Kepler for vulnerabilities
        let vulnerabilities = self.kepler_client
            .search_cves(&process.name, &process.version)
            .await?;

        let vulnerability_count = vulnerabilities.len();

        if vulnerability_count > 0 {
            self.handle_vulnerabilities_found(process.clone(), vulnerabilities).await?;
        } else {
            info!("âœ… No known vulnerabilities found for {} v{}", process.name, process.version);
        }

        // Emit process scanned event
        self.emit_event(VulnerabilityEvent::ProcessScanned {
            timestamp: Utc::now(),
            process,
            vulnerability_count,
        });

        Ok(())
    }

    async fn handle_vulnerabilities_found(&self, process: ProcessInfo, vulnerabilities: Vec<CVE>) -> Result<()> {
        let vulnerability_count = vulnerabilities.len();
        self.add_to_stat("vulnerabilities_found", vulnerability_count as u64).await;

        let severity = Self::calculate_overall_severity(&vulnerabilities);
        let alert_level = Self::determine_alert_level(&vulnerabilities, self.config.detection.min_cvss_score);

        let detection = VulnerabilityDetection {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: Utc::now(),
            process: process.clone(),
            vulnerabilities: vulnerabilities.clone(),
            severity: severity.clone(),
            alert_level: alert_level.clone(),
        };

        // Store detection
        let process_key = format!("{}:{}", process.name, process.version);
        self.detections.insert(process_key, detection.clone());

        // Generate alerts
        self.generate_alerts(&detection).await;

        // Emit vulnerability detected event
        self.emit_event(VulnerabilityEvent::VulnerabilityDetected { detection });

        Ok(())
    }

    async fn handle_process_exit(&self, _pid: i32, _name: &str) {
        debug!("Process {} (PID: {}) exited", _name, _pid);
        // For now, we don't remove detections when processes exit
        // In a real implementation, you might want to clean up or mark as inactive
    }

    async fn generate_alerts(&self, detection: &VulnerabilityDetection) {
        let high_severity_vulns: Vec<_> = detection.vulnerabilities
            .iter()
            .filter(|v| {
                v.cvss_score() >= self.config.detection.min_cvss_score ||
                matches!(v.severity().as_str(), "HIGH" | "CRITICAL")
            })
            .collect();

        if !high_severity_vulns.is_empty() {
            self.increment_stat("high_severity_alerts").await;
            
            warn!("ðŸš¨ HIGH SEVERITY VULNERABILITY ALERT ðŸš¨");
            warn!("Process: {} v{} (PID: {})", detection.process.name, detection.process.version, detection.process.pid);
            warn!("Command: {}", detection.process.command);
            warn!("High-severity vulnerabilities: {}", high_severity_vulns.len());
            
            for vuln in &high_severity_vulns {
                warn!("  â€¢ {}: {}", vuln.cve_id, truncate_string(&vuln.summary, 100));
                warn!("    CVSS: {} | Severity: {}", vuln.cvss_score(), vuln.severity());
            }
        } else {
            info!("âš ï¸ Vulnerabilities detected in {} v{}", detection.process.name, detection.process.version);
            info!("Found {} CVE(s) with lower severity", detection.vulnerabilities.len());
            
            for vuln in &detection.vulnerabilities {
                info!("  â€¢ {}: CVSS {} ({})", vuln.cve_id, vuln.cvss_score(), vuln.severity());
            }
        }
    }

    fn calculate_overall_severity(vulnerabilities: &[CVE]) -> SeverityLevel {
        let max_score = vulnerabilities.iter()
            .map(|v| v.cvss_score())
            .fold(0.0, f64::max);

        let has_critical = vulnerabilities.iter().any(|v| v.severity() == "CRITICAL");
        let has_high = vulnerabilities.iter().any(|v| v.severity() == "HIGH");

        if has_critical || max_score >= 9.0 {
            SeverityLevel::Critical
        } else if has_high || max_score >= 7.0 {
            SeverityLevel::High
        } else if max_score >= 4.0 {
            SeverityLevel::Medium
        } else {
            SeverityLevel::Low
        }
    }

    fn determine_alert_level(vulnerabilities: &[CVE], min_cvss_score: f64) -> AlertLevel {
        let max_score = vulnerabilities.iter()
            .map(|v| v.cvss_score())
            .fold(0.0, f64::max);

        if max_score >= 9.0 {
            AlertLevel::Critical
        } else if max_score >= min_cvss_score {
            AlertLevel::High
        } else if max_score >= 4.0 {
            AlertLevel::Medium
        } else if max_score > 0.0 {
            AlertLevel::Low
        } else {
            AlertLevel::Info
        }
    }

    pub async fn get_all_detections(&self) -> Vec<VulnerabilityDetection> {
        self.detections.iter().map(|entry| entry.value().clone()).collect()
    }

    pub async fn get_detections_by_severity(&self, severity: &SeverityLevel) -> Vec<VulnerabilityDetection> {
        self.detections
            .iter()
            .filter(|entry| &entry.value().severity == severity)
            .map(|entry| entry.value().clone())
            .collect()
    }

    pub async fn get_stats(&self) -> EngineStats {
        let mut stats = self.stats.read().await.clone();
        stats.unique_vulnerable_processes = self.detections.len() as u64;
        
        // Get cache stats from Kepler client
        let (cache_entries, _cache_size) = self.kepler_client.get_cache_stats();
        stats.cache_hits = cache_entries; // Simplified
        
        stats
    }

    pub async fn generate_summary_report(&self) -> serde_json::Value {
        let stats = self.get_stats().await;
        let detections = self.get_all_detections().await;
        
        let mut severity_counts = std::collections::HashMap::new();
        severity_counts.insert("CRITICAL", 0);
        severity_counts.insert("HIGH", 0);
        severity_counts.insert("MEDIUM", 0);
        severity_counts.insert("LOW", 0);

        for detection in &detections {
            let severity_str = match detection.severity {
                SeverityLevel::Critical => "CRITICAL",
                SeverityLevel::High => "HIGH",
                SeverityLevel::Medium => "MEDIUM",
                SeverityLevel::Low => "LOW",
            };
            *severity_counts.get_mut(severity_str).unwrap() += 1;
        }

        serde_json::json!({
            "timestamp": Utc::now(),
            "stats": stats,
            "severity_breakdown": severity_counts,
            "vulnerable_processes": detections.iter().map(|d| {
                serde_json::json!({
                    "process": format!("{} v{}", d.process.name, d.process.version),
                    "severity": d.severity,
                    "vulnerability_count": d.vulnerabilities.len(),
                    "detected_at": d.timestamp
                })
            }).collect::<Vec<_>>()
        })
    }

    fn emit_event(&self, event: VulnerabilityEvent) {
        if let Err(e) = self.event_sender.send(event) {
            error!("Failed to emit vulnerability event: {}", e);
        }
    }

    async fn increment_stat(&self, stat_name: &str) {
        self.add_to_stat(stat_name, 1).await;
    }

    async fn add_to_stat(&self, stat_name: &str, value: u64) {
        let mut stats = self.stats.write().await;
        match stat_name {
            "events_processed" => stats.events_processed += value,
            "processes_scanned" => stats.processes_scanned += value,
            "vulnerabilities_found" => stats.vulnerabilities_found += value,
            "high_severity_alerts" => stats.high_severity_alerts += value,
            "cache_hits" => stats.cache_hits += value,
            "cache_misses" => stats.cache_misses += value,
            _ => {}
        }
    }
}

impl Default for EngineStats {
    fn default() -> Self {
        Self {
            events_processed: 0,
            processes_scanned: 0,
            vulnerabilities_found: 0,
            high_severity_alerts: 0,
            unique_vulnerable_processes: 0,
            cache_hits: 0,
            cache_misses: 0,
        }
    }
}

fn truncate_string(s: &str, max_length: usize) -> String {
    if s.len() <= max_length {
        s.to_string()
    } else {
        format!("{}...", &s[..max_length.saturating_sub(3)])
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_overall_severity() {
        let critical_cves = vec![
            CVE {
                cve_id: "CVE-2021-1234".to_string(),
                summary: "Critical vulnerability".to_string(),
                cvss_score: 9.5,
                severity: "CRITICAL".to_string(),
                published_date: "2021-01-01".to_string(),
                references: vec![],
            }
        ];
        
        assert_eq!(VulnerabilityEngine::calculate_overall_severity(&critical_cves), SeverityLevel::Critical);
        
        let high_cves = vec![
            CVE {
                cve_id: "CVE-2021-5678".to_string(),
                summary: "High vulnerability".to_string(),
                cvss_score: 7.5,
                severity: "HIGH".to_string(),
                published_date: "2021-01-01".to_string(),
                references: vec![],
            }
        ];
        
        assert_eq!(VulnerabilityEngine::calculate_overall_severity(&high_cves), SeverityLevel::High);
    }

    #[test]
    fn test_determine_alert_level() {
        let cves = vec![
            CVE {
                cve_id: "CVE-2021-1234".to_string(),
                summary: "Test vulnerability".to_string(),
                cvss_score: 8.5,
                severity: "HIGH".to_string(),
                published_date: "2021-01-01".to_string(),
                references: vec![],
            }
        ];
        
        assert_eq!(VulnerabilityEngine::determine_alert_level(&cves, 7.0), AlertLevel::High);
        assert_eq!(VulnerabilityEngine::determine_alert_level(&cves, 9.0), AlertLevel::Medium);
    }

    #[test]
    fn test_truncate_string() {
        assert_eq!(truncate_string("short", 10), "short");
        assert_eq!(truncate_string("this is a very long string that should be truncated", 20), "this is a very lo...");
    }
}